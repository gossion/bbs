package migrations

import (
	"database/sql"

	"code.cloudfoundry.org/bbs/db/etcd"
	"code.cloudfoundry.org/bbs/db/sqldb"
	"code.cloudfoundry.org/bbs/encryption"
	"code.cloudfoundry.org/bbs/migration"
	"code.cloudfoundry.org/clock"
	"code.cloudfoundry.org/lager"
)

func init() {
	AppendMigration(NewSQLTestMigration(9999999999))
}

type SQLTestMigration struct {
	version  int64
	rawSQLDB *sql.DB
	dbFlavor string
}

func NewSQLTestMigration(version int64) migration.Migration {
	return &SQLTestMigration{
		version: version,
	}
}

func (t *SQLTestMigration) SetStoreClient(storeClient etcd.StoreClient) {}

func (*SQLTestMigration) SetCryptor(cryptor encryption.Cryptor) {}

func (t *SQLTestMigration) SetRawSQLDB(rawSQLDB *sql.DB) {
	t.rawSQLDB = rawSQLDB
}

func (*SQLTestMigration) SetClock(clock.Clock) {}
func (t *SQLTestMigration) SetDBFlavor(flavor string)   {
	t.dbFlavor = flavor
}

func (*SQLTestMigration) RequiresSQL() bool {
	return true
}

func (t *SQLTestMigration) Up(logger lager.Logger) error {
	var query string
	if t.dbFlavor == sqldb.MSSQL {
		query = `IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='sweet_table' AND xtype='U')
			CREATE TABLE sweet_table (
			something VARCHAR(255) PRIMARY KEY,
			something_else INT DEFAULT 0
		);`
	} else {
		query = `CREATE TABLE IF NOT EXISTS sweet_table (
			something VARCHAR(255) PRIMARY KEY,
			something_else INT DEFAULT 0
		);`
	}

	_, err := t.rawSQLDB.Exec(query)

	return err
}

func (t *SQLTestMigration) Down(logger lager.Logger) error {
	// do nothing until we get rollback
	return nil
}

func (t SQLTestMigration) Version() int64 {
	return t.version
}
